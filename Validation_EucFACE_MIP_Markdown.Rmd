---
title: "EucFACE Simulation Output Validation"
author: "Mingkai Jiang"
date: "`r Sys.Date()`"
output: pdf_document

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width=4, fig.height=3)


#### clear wk space
rm(list=ls(all=TRUE))

#### Source functions and packages
source("prepare.R")

#### select the model abbreviation
#### options are:
####             GDAYN: GDAY, CN version
####             GDAYP: GDAY, CNP version
####             QUNIC: QUINCY
####             OCHDP: ORCHIDEE, CNP version
####             OCHDN: ORCHIDEE, CN version
####             LPJGN: LPJ-Guess, CN version
####             LPJGP: LPJ-Guess, CNP version
####             CABLP: CABLE-POP, CNP version
####             ELMXX: ELM, CNP version

mod.abb <- "GDAYP"


```




## 1. Introduction

This is an R Markdown document to evaluate the model simulation results for the new EucFACE multi-model intercomparison project, based on mass balance checks and validation datasets. 



To use this Markdown, please create two folders within this repository and place the relevant data files into each folder. 

- Create a folder "simulation_output", and place the model simulation results into this folder (note, only the file containing ambient treatment over the period of 2012 - 2019).

- Create a folder "validation_dataset", and place the validation datasets into this folder (data can be obtained via the CloudStor link sent previously).



This output of this script is organized in the following order:

* Step 2: Checking mass balance. This section will check mass balance of model output, including major carbon, water, nitrogen and phosphorus cycle variables.  
* Step 3: Checking time-invariance variables against validation data. This section will check some key pools and fluxes against the validation dataset. All validation data are provided in the EucFACE parameter list file. Note that the data are either averaged over time, or one fixed value measured at one point. 
* Step 4: Checking time-varying variables against some validation data. This section will check some temporal patterns of the simulation results against some validation datasets. 
    
Finally, please note that, all checks are performed for the ambient CO2 treatment only, over the period where observations are available (i.e. 2012 - 2019). For the validation against observation dataset, please also use simulation results under the no P addition and variable climate forcing scenario. 



```{r, echo=FALSE, message=FALSE, warning=FALSE}
### read in simulation results and get it in shape for comparison.
### the naming of the file follows rules identified in the output protocol. 
### Note that this is the daily file. 
modDF <- read.csv(paste0("simulation_output/EUC_", mod.abb, "_OBS_VAR_AMB_NOP_D.csv"),
                  skip=1)

### checking number of column in the original dataframe
ncol <- ncol(modDF)
#print(paste0("no. of columns is ", ncol))

# check length of frames, need to be TRUE, otherwise you have too many or little days
# 8 years with 365 days plus 2 years with a leap day! (for those models that do not model leap days, please repeat Feb 28 to fill Feb 29)
if (nrow(modDF)!=(8*365)+2) 
  {print(paste("number of rows of model output does not match, all further results unreliable!!"))}


### add date to the dataset
for (i in 2012:2019) {
    
    date.list <- as.Date((modDF$doy[modDF$year==i]-1), 
                                           origin = paste0(i, "-01-01"))
    
    modDF$Date[modDF$year == i] <- as.character(date.list)
}

modDF$Date <- as.Date(modDF$Date)


### revise the GDAY output names following output protocol (delete this once GDAY output is properly set)
### the rest of the codes in this chunk only applies to GDAY.
### other models may need to modify this section to continue.
names(modDF)[names(modDF) == "lai"] <- "LAI"
names(modDF)[names(modDF) == "hetero_resp"] <- "RHET"
names(modDF)[names(modDF) == "shoot"] <- "CL"
names(modDF)[names(modDF) == "root"] <- "CFR"
names(modDF)[names(modDF) == "croot"] <- "CCR"

names(modDF)[names(modDF) == "pmineralisation"] <- "PMIN"
names(modDF)[names(modDF) == "inorglabp"] <- "PLAB"
names(modDF)[names(modDF) == "nmineralisation"] <- "NMIN"

names(modDF)[names(modDF) == "soilc"] <- "CSOIL"
names(modDF)[names(modDF) == "soiln"] <- "NSOIL"
names(modDF)[names(modDF) == "soilp"] <- "PSOIL"

names(modDF)[names(modDF) == "shootn"] <- "NL"
names(modDF)[names(modDF) == "rootn"] <- "NFR"
names(modDF)[names(modDF) == "crootn"] <- "NCR"
names(modDF)[names(modDF) == "shootp"] <- "PL"
names(modDF)[names(modDF) == "rootp"] <- "PFR"
names(modDF)[names(modDF) == "crootp"] <- "PCR"

names(modDF)[names(modDF) == "leafretransn"] <- "NLRETR"
names(modDF)[names(modDF) == "leafretransp"] <- "PLRETR"

names(modDF)[names(modDF) == "nloss"] <- "NLEACH"
names(modDF)[names(modDF) == "ploss"] <- "PLEACH"

names(modDF)[names(modDF) == "nuptake"] <- "NUP"
names(modDF)[names(modDF) == "puptake"] <- "PUP"

names(modDF)[names(modDF) == "cpleaf"] <- "CGL"
names(modDF)[names(modDF) == "cproot"] <- "CGFR"
names(modDF)[names(modDF) == "cpcroot"] <- "CGCR"

names(modDF)[names(modDF) == "npleaf"] <- "NGL"
names(modDF)[names(modDF) == "nproot"] <- "NGFR"
names(modDF)[names(modDF) == "npcroot"] <- "NGCR"

names(modDF)[names(modDF) == "ppleaf"] <- "PGL"
names(modDF)[names(modDF) == "pproot"] <- "PGFR"
names(modDF)[names(modDF) == "ppcroot"] <- "PGCR"

names(modDF)[names(modDF) == "nep"] <- "NEP"
names(modDF)[names(modDF) == "gpp"] <- "GPP"
names(modDF)[names(modDF) == "npp"] <- "NPP"
names(modDF)[names(modDF) == "auto_resp"] <- "RAU"


### change all other column names
names(modDF)[names(modDF) == "cstore"] <- "CSTOR"
names(modDF)[names(modDF) == "nstore"] <- "NSTOR"
names(modDF)[names(modDF) == "pstore"] <- "PSTOR"

names(modDF)[names(modDF) == "inorgn"] <- "NPMIN"
names(modDF)[names(modDF) == "inorgp"] <- "PPMIN"

names(modDF)[names(modDF) == "inorgoccp"] <- "POCC"
names(modDF)[names(modDF) == "inorgparp"] <- "PPAR"

names(modDF)[names(modDF) == "litterc"] <- "CFLIT"
names(modDF)[names(modDF) == "littercag"] <- "CFLITA"
names(modDF)[names(modDF) == "littercbg"] <- "CFLITB"

names(modDF)[names(modDF) == "litternag"] <- "NFLITA"
names(modDF)[names(modDF) == "litternbg"] <- "NFLITB"

names(modDF)[names(modDF) == "litterpag"] <- "PFLITA"
names(modDF)[names(modDF) == "litterpbg"] <- "PFLITB"

names(modDF)[names(modDF) == "et"] <- "ET"
names(modDF)[names(modDF) == "transpiration"] <- "Transpiration"
names(modDF)[names(modDF) == "soil_evap"] <- "ES"
names(modDF)[names(modDF) == "canopy_evap"] <- "EC"
names(modDF)[names(modDF) == "runoff"] <- "RO"

names(modDF)[names(modDF) == "ngross"] <- "NGMIN"
names(modDF)[names(modDF) == "pgross"] <- "PGMIN"
names(modDF)[names(modDF) == "p_slow_biochemical"] <- "PBIOCHMIN"

names(modDF)[names(modDF) == "deadleaves"] <- "CLITIN"
names(modDF)[names(modDF) == "deadroots"] <- "CFRLIN"
names(modDF)[names(modDF) == "deadcroots"] <- "CCRLIN"

names(modDF)[names(modDF) == "deadleafn"] <- "NLITIN"
names(modDF)[names(modDF) == "deadrootn"] <- "NFRLIN"
names(modDF)[names(modDF) == "deadcrootn"] <- "NCRLIN"

names(modDF)[names(modDF) == "deadleafp"] <- "PLITIN"
names(modDF)[names(modDF) == "deadrootp"] <- "PFRLIN"
names(modDF)[names(modDF) == "deadcrootp"] <- "PCRLIN"


### add extra column where GDAY simulation doesn't output for now
# coarse root respiration
modDF$RCR <- 0.0

# fine root respiration
modDF$RFR <- 0.0

### reproduction growth
modDF$CREPR <- 0.0

### coarse litter
modDF$CCLITB <- 0.0
modDF$NCLITB <- 0.0
modDF$PCLITB <- 0.0

### drainage
modDF$DRAIN <- 0.0

### C exudation
modDF$CEX <- 0.0

### CVOC
modDF$CVOC <- 0.0

### leaf respiration
modDF$RL <- 0.0

### wood respiration
modDF$RW <- 0.0

### growth respiration
modDF$RGR <- 0.0


# merge branch and stem together to create wood
modDF$CW <- modDF$branch + modDF$stem
modDF$NW <- modDF$branchn + modDF$stemn
modDF$PW <- modDF$branchp + modDF$stemp

modDF$CGW <- modDF$cpbranch + modDF$cpstem
modDF$NGW <- modDF$npbranch + modDF$npstemimm
modDF$PGW <- modDF$ppbranch + modDF$ppstemimm


### merge sorb and strongly sorbed P as secondary P
modDF$PSEC <- modDF$inorgsorbp + modDF$inorgssorbp

### ecosystem respiration
modDF$RECO <- modDF$RAU + modDF$RHET

### wood litter input
modDF$CWLIN <- modDF$deadbranch + modDF$deadstems
modDF$NWLIN <- modDF$deadbranchn + modDF$deadstemn
modDF$PWLIN <- modDF$deadbranchp + modDF$deadstemp


### add retranslocation for wood and root
modDF$NWRETR <- 0.0
modDF$PWRETR <- 0.0

modDF$NCRRETR <- 0.0
modDF$NFRRETR <- 0.0

modDF$PCRRETR <- 0.0
modDF$PFRRETR <- 0.0

### N and P FLIT flux
modDF$NFLIT <- modDF$NFLITA + modDF$NFLITB
modDF$PFLIT <- modDF$PFLITA + modDF$PFLITB

### N fixation
modDF$NFIX <- 0.0
modDF$NVOL <- 0.0

### N and P deposition
modDF$NDEP <- 2.25/1000/100/365
modDF$PDEP <- 0.093/1000/100/365

### N and P in organic form
modDF$NPORG <- modDF$activesoiln+modDF$slowsoiln+modDF$passivesoiln
modDF$PPORG <- modDF$activesoilp+modDF$slowsoilp+modDF$passivesoilp

### P weathering rate
modDF$PWEA <- 0.0



### convert unit from current GDAY default of t ha-1 to whatever is defined in the output protocol (gC m-2)
modDF$RHET <- with(modDF, RHET * 100)
modDF$RECO <- with(modDF, RECO * 100)
modDF$RFR <- with(modDF, RFR * 100)
modDF$RCR <- with(modDF, RCR * 100)
modDF$CL <- with(modDF, CL * 100)
modDF$CW <- with(modDF, CW * 100)
modDF$CFR <- with(modDF, CFR * 100)
modDF$CCR <- with(modDF, CCR * 100)

modDF$CSOIL <- with(modDF, CSOIL * 100)
modDF$NSOIL <- with(modDF, NSOIL * 100)
modDF$PSOIL <- with(modDF, PSOIL * 100)

modDF$PMIN <- with(modDF, PMIN * 100)
modDF$PLAB <- with(modDF, PLAB * 100)
modDF$NMIN <- with(modDF, NMIN * 100)

modDF$NL <- with(modDF, NL * 100)
modDF$NW <- with(modDF, NW * 100)
modDF$NFR <- with(modDF, NFR * 100)
modDF$NCR <- with(modDF, NCR * 100)
modDF$PL <- with(modDF, PL * 100)
modDF$PW <- with(modDF, PW * 100)
modDF$PFR <- with(modDF, PFR * 100)
modDF$PCR <- with(modDF, PCR * 100)

modDF$NLRETR <- with(modDF, NLRETR * 100)
modDF$PLRETR <- with(modDF, PLRETR * 100)

modDF$NLEACH <- with(modDF, NLEACH * 100)
modDF$PLEACH <- with(modDF, PLEACH * 100)

modDF$NUP <- with(modDF, NUP * 100)
modDF$PUP <- with(modDF, PUP * 100)

modDF$CGL <- with(modDF, CGL * 100)
modDF$CGW <- with(modDF, CGW * 100)
modDF$CGFR <- with(modDF, CGFR * 100)
modDF$CGCR <- with(modDF, CGCR * 100)

modDF$NGL <- with(modDF, NGL * 100)
modDF$NGW <- with(modDF, NGW * 100)
modDF$NGFR <- with(modDF, NGFR * 100)
modDF$NGCR <- with(modDF, NGCR * 100)

modDF$PGL <- with(modDF, PGL * 100)
modDF$PGW <- with(modDF, PGW * 100)
modDF$PGFR <- with(modDF, PGFR * 100)
modDF$PGCR <- with(modDF, PGCR * 100)

modDF$NEP <- with(modDF, NEP * 100)
modDF$GPP <- with(modDF, GPP * 100)
modDF$NPP <- with(modDF, NPP * 100)
modDF$RAU <- with(modDF, RAU * 100)

modDF$CSTOR <- modDF$CSTOR * 100
modDF$NSTOR <- modDF$NSTOR * 100
modDF$PSTOR <- modDF$PSTOR * 100

modDF$NPMIN <- modDF$NPMIN * 100
modDF$PPMIN <- modDF$PPMIN * 100

modDF$POCC <- modDF$POCC * 100
modDF$PPAR <- modDF$PPAR * 100

modDF$CFLIT <- modDF$CFLIT * 100
modDF$CFLITA <- modDF$CFLITA * 100
modDF$CFLITB <- modDF$CFLITB * 100

#modDF$NFLIT <- modDF$NFLIT * 100
modDF$NFLITA <- modDF$NFLITA * 100
modDF$NFLITB <- modDF$NFLITB * 100

#modDF$PFLIT <- modDF$PFLIT * 100
modDF$PFLITA <- modDF$PFLITA * 100
modDF$PFLITB <- modDF$PFLITB * 100

modDF$Transpiration <- modDF$Transpiration * 100 / 1000 # kg H2O m2 d-1
modDF$ET <- modDF$ET * 100 / 1000 # kg H2O m2 d-1
modDF$ES <- modDF$ES * 100 / 1000 # kg H2O m2 d-1
modDF$EC <- modDF$EC * 100 / 1000 # kg H2O m2 d-1
modDF$RO <- modDF$RO * 100 / 1000 # kg H2O m2 d-1
modDF$DRAIN <- modDF$DRAIN * 100 / 1000 # kg H2O m2 d-1

modDF$CCLITB <- modDF$CCLITB * 100
modDF$NCLITB <- modDF$NCLITB * 100
modDF$PCLITB <- modDF$PCLITB * 100

modDF$PSEC <- modDF$PSEC * 100

modDF$CEX <- modDF$CEX * 100
modDF$CVOC <- modDF$CVOC * 100

modDF$RL <- modDF$RL * 100
modDF$RW <- modDF$RW * 100
modDF$RGR <- modDF$RGR * 100

modDF$NGMIN <- modDF$NGMIN * 100
modDF$PGMIN <- modDF$PGMIN * 100
modDF$PBIOCHMIN <- modDF$PBIOCHMIN * 100

modDF$CLITIN <- modDF$CLITIN * 100
modDF$CFRLIN <- modDF$CFRLIN * 100
modDF$CCRLIN <- modDF$CCRLIN * 100
modDF$CWLIN <- modDF$CWLIN * 100

modDF$NLITIN <- modDF$NLITIN * 100
modDF$NFRLIN <- modDF$NFRLIN * 100
modDF$NCRLIN <- modDF$NCRLIN * 100
modDF$NWLIN <- modDF$NWLIN * 100

modDF$PLITIN <- modDF$PLITIN * 100
modDF$PFRLIN <- modDF$PFRLIN * 100
modDF$PCRLIN <- modDF$PCRLIN * 100
modDF$PWLIN <- modDF$PWLIN * 100

modDF$NFLIT <- modDF$NFLIT * 100
modDF$PFLIT <- modDF$PFLIT * 100

modDF$NDEP <- modDF$NDEP * 100
modDF$PDEP <- modDF$PDEP * 100

modDF$NPORG <- modDF$NPORG * 100
modDF$PPORG <- modDF$PPORG * 100

modDF$PWEA <- modDF$PWEA * 100



```


## 2. Checking mass balance

We will need to check mass balance for major variables first before validating the simulation results with observations. The mass balance check is performed at annual timestep. 

Below we check the mass balance for carbon, water, nitrogen and phopshorus variables, each with a plot. 

Note that, I assume that many models may not output some of these variables, and as such, the mass balance may not close without the inclusion model-specific variables. For those that are relevant, please modify the script with additional/alternative variables to try to close the mass balance. Otherwise, please indicate the reasons as to why your model does not have mass balance closure.



```{r, echo=FALSE, message=FALSE, warning=FALSE}

### summarize all fluxes first to obain annual rate
fluxDF <- summaryBy(ET+Transpiration+ES+EC+RO+DRAIN+NEP+GPP+NPP+RHET+RAU+RECO+CGL+CGFR+CGCR+CGW+NGL+NGFR+NGCR+NGW+PGL+PGFR+PGCR+PGW+NUP+NGMIN+NMIN+NLEACH+PUP+PGMIN+PMIN+PLEACH+PBIOCHMIN+NLRETR+PLRETR+RCR+RFR+CREPR+CEX+CVOC+RL+RW+RGR+CLITIN+CCRLIN+CFRLIN+CWLIN+NLITIN+NCRLIN+NFRLIN+NWLIN+PLITIN+PCRLIN+PFRLIN+PWLIN+NWRETR+PWRETR+NCRRETR+PCRRETR+NFRRETR+PFRRETR+NDEP+NFIX+NVOL+PDEP+PWEA~year, data=modDF, FUN=sum, keep.names=T, na.rm=T)


### subset first day of all pools
poolDF <- modDF[,c("year", "doy", "CL","LAI","CW","CFR","CCR","NL","NW","NFR","NCR","PL","PW","PFR","PCR","CSTOR","NSTOR","PSTOR",
                   "CSOIL","NSOIL","PSOIL","NPMIN","PPMIN","PLAB","PSEC","POCC","PPAR","CFLIT","CFLITA","CFLITB",
                   "NFLITA","NFLITB","PFLITA","PFLITB","CCLITB","NCLITB","PCLITB","NFLIT","PFLIT", "NPORG", "PPORG")]

poolDF <- subset(poolDF, doy==1)

poolDF$doy <- NULL

### calculate change in pools for mass balance
deltaDF <- poolDF[poolDF$year < 2019,]

l <- dim(deltaDF)[2]

for (i in c(2012:2018)) {
    deltaDF[deltaDF$year==i,2:l] <- poolDF[poolDF$year==(i+1),2:l]-poolDF[poolDF$year==i,2:l]
}

### add delta column name to deltaDF
names(deltaDF)[2:l] <- paste0("delta", names(deltaDF[2:l]))

### merge all dataframe together
annDF <- merge(fluxDF, poolDF, by="year")
annDF <- merge(annDF, deltaDF, by="year", all.x=T)

### calculate annual maximum for some variables
maxDF <- summaryBy(LAI+CL+CFR+CSTOR+NL+NFR+NSTOR+PL+NFR+PSTOR~year, data=modDF, keep.names=T, na.rm=T)


```


#### 2.1 Carbon balance

Now we plot carbon-related mass balance results. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on GPP", fig.align="center"}

p1<-xyplot(I(NPP+RAU)~GPP,fluxDF,
           main='NPP+RAU~GPP',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on GPP", fig.align="center"}

p1<-xyplot(I(NEP+RECO)~GPP,fluxDF,
           main='NEP+RECO~GPP',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on RECO", fig.align="center"}

p1<-xyplot(I(RHET+RAU)~RECO,fluxDF,
           main='RHET+RAUTO~RECO',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on RAU", fig.align="center"}

p1<-xyplot(I(RL+RW+RCR+RFR+RGR)~RAU,fluxDF,
           main='RL+RW+RCR+RFR+RGR~RAU',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Scaling of LAI with CL", fig.align="center"}

p1<-xyplot(LAI~CL,poolDF,
           main='LAI~CL',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta CL", fig.align="center"}

p1<-xyplot(I(CGL-CLITIN)~deltaCL,annDF,
           main='CGL-CLITIN~deltaCL',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta CW", fig.align="center"}

p1<-xyplot(I(CGW-CWLIN)~deltaCW,annDF,
           main='CGW-CWLIN~deltaCW',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta CFR", fig.align="center"}

p1<-xyplot(I(CGFR-CFRLIN)~deltaCFR,annDF,
           main='CGFR-CFRLIN~deltaCFR',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta CCR", fig.align="center"}

p1<-xyplot(I(CGCR-CCRLIN)~deltaCCR,annDF,
           main='CGCR-CCRLIN~deltaCCR',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on GPP", fig.align="center"}

p1<-xyplot(I(RAU+CGL+CGFR+CGCR+CGW+CREPR)~GPP,annDF,
           main='I(RAU+CGL+CGFR+CGCR+CGW+CREPR)~GPP',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on NPP", fig.align="center"}

p1<-xyplot(I(CGW+CGL+CGFR+CGCR+CREPR)~NPP,annDF,
           main='I(CGW+CGL+CGFR+CGCR+CREPR)~NPP',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on NPP", fig.align="center"}

p1<-xyplot(I(CGW+CGL+CGFR+CGCR+CREPR+deltaCSTOR)~NPP,annDF,
           main='I(CGW+CGL+CGFR+CGCR+CREPR+deltaCSTOR)~NPP',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on CFLIT", fig.align="center"}

p1<-xyplot(I(CFLITA+CFLITB)~CFLIT,annDF,
           main='CFLITA+CFLITB~CFLIT',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta soil", fig.align="center"}

p1<-xyplot(I(CLITIN+CWLIN+CFRLIN+CCRLIN+CREPR-RHET)~I(deltaCSOIL+deltaCCLITB+deltaCFLIT),annDF,
           main='I(CLITIN+CWLIN+CFRLIN+CCRLIN+CREPR-RHET)~I(deltaCSOIL+deltaCCLITB+deltaCFLIT)',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



#### 2.2. Water balance

Next we plot some very basic water balance checks. More will be added later. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on ET", fig.align="center"}

p1<-xyplot(I(ES+EC+Transpiration)~ET,fluxDF,
           main='ES+EC+T~ET',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



#### 2.3. Nitrogen balance

Now we plot some nitrogen balance checks. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta NL", fig.align="center"}

p1<-xyplot(I(NGL-NLITIN-NLRETR)~deltaNL,annDF,
           main='I(NGL-NLITIN-NLRETR)~deltaNL',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta NW", fig.align="center"}

p1<-xyplot(I(NGW-NWLIN-NWRETR)~deltaNW,annDF,
           main='I(NGW-NWLIN-NWRETR)~deltaNW',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta NFR", fig.align="center"}

p1<-xyplot(I(NGFR-NFRLIN-NFRRETR)~deltaNFR,annDF,
           main='I(NGFR-NFRLIN-NFRRETR)~deltaNFR',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta NCR", fig.align="center"}

p1<-xyplot(I(NGCR-NCRLIN-NCRRETR)~deltaNCR,annDF,
           main='I(NGCR-NCRLIN-NCRRETR)~deltaNCR',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on NFLIT", fig.align="center"}

p1<-xyplot(I(NFLITA+NFLITB)~NFLIT,annDF,
           main='I(NFLITA+NFLITB)~NFLIT',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on N input and output", fig.align="center"}

p1<-xyplot(I(NUP+NLRETR+NWRETR+NFRRETR+NCRRETR)~I(NGL+NGFR+NGCR+NGW),annDF,
           main='I(NUP+NLRETR+NWRETR+NFRRETR+NCRRETR)~I(NGL+NGFR+NGCR+NGW)',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta NSTOR", fig.align="center"}

p1<-xyplot(I(NUP+NLRETR+NWRETR+NFRRETR+NCRRETR-NGL-NGFR-NGCR-NGW)~deltaNSTOR,annDF,
           main='I(NUP+NLRETR+NWRETR+NFRRETR+NCRRETR-NGL-NGFR-NGCR-NGW)~deltaNSTOR',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on N input and output", fig.align="center"}

#p1<-xyplot(I(NFIX+NUP+NLRETR+NWRETR+NFRRETR+NCRRETR)~I(NGL+NGFR+NGCR+NGW),annDF,
#           main='I(NFIX+NUP+NLRETR+NWRETR+NFRRETR+NCRRETR)~I(NGL+NGFR+NGCR+NGW)',auto.key=T,
#           scales=list(relation='free'),
#           panel=function(...){
#             panel.xyplot(...)
#             panel.abline(a=0,b=1)}) 
#
#plot(p1)


```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on N input and output", fig.align="center"}

#p1<-xyplot(I(NFIX+NUP+NLRETR+NWRETR+NFRRETR+NCRRETR-NGL-NGFR-NGCR-NGW)~deltaNSTOR,annDF,
#           main='I(NFIX+NUP+NLRETR+NWRETR+NFRRETR+NCRRETR-NGL-NGFR-NGCR-NGW)~deltaNSTOR',auto.key=T,
#           scales=list(relation='free'),
#           panel=function(...){
#             panel.xyplot(...)
#             panel.abline(a=0,b=1)}) 
#
#plot(p1)


```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on ecosystem N", fig.align="center"}

p1<-xyplot(I(NDEP+NFIX-NLEACH-NVOL)~(I(deltaNL+deltaNW+deltaNCR+deltaNFR+deltaNSOIL+deltaNFLIT+deltaNCLITB)),annDF,
           main='I(NDEP+NFIX-NLEACH-NVOL)~(I(deltaNL+deltaNW+deltaNCR+deltaNFR+deltaNSOIL+deltaNFLIT+deltaNCLITB))',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on ecosystem N", fig.align="center"}

p1<-xyplot(I(NDEP+NFIX+NLITIN+NWLIN+NCRLIN+NFRLIN-NUP-NLEACH-NVOL)~I(deltaNSOIL+deltaNFLIT+deltaNCLITB),annDF,
           main='I(NDEP+NFIX+NLITIN+NWLIN+NCRLIN+NFRLIN-NUP-NLEACH-NVOL)~I(deltaNSOIL+deltaNFLIT+deltaNCLITB)',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on ecosystem N", fig.align="center"}

p1<-xyplot(I(NDEP+NLITIN+NWLIN+NCRLIN+NFRLIN-NUP-NLEACH-NVOL)~I(deltaNSOIL+deltaNFLIT+deltaNCLITB),annDF,
           main='I(NDEP+NLITIN+NWLIN+NCRLIN+NFRLIN-NUP-NLEACH-NVOL)~I(deltaNSOIL+deltaNFLIT+deltaNCLITB)',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on soil N", fig.align="center"}

p1<-xyplot(I(NPMIN+NPORG)~NSOIL,annDF,
           main='I(NPMIN+NPORG)~NSOIL',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```



#### Phosphorus balance


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on P input and output", fig.align="center"}

p1<-xyplot(I(PDEP+PWEA-PLEACH)~(I(deltaPL+deltaPW+deltaPCR+deltaPFR+deltaPSOIL+deltaPFLIT+deltaPCLITB)),annDF,
           main='I(PDEP+PWEA-PLEACH)~(I(deltaPL+deltaPW+deltaPCR+deltaPFR+deltaPSOIL+deltaPFLIT+deltaPCLITB))',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta PL", fig.align="center"}

p1<-xyplot(I(PGL-PLITIN-PLRETR)~deltaPL,annDF,
           main='I(PGL-PLITIN-PLRETR)~deltaPL',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta PW", fig.align="center"}

p1<-xyplot(I(PGW-PWLIN-PWRETR)~deltaPW,annDF,
           main='I(PGW-PWLIN-PWRETR)~deltaPW',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta PFR", fig.align="center"}

p1<-xyplot(I(PGFR-PFRLIN-PFRRETR)~deltaPFR,annDF,
           main='I(PGFR-PFRLIN-PFRRETR)~deltaPFR',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta PCR", fig.align="center"}

p1<-xyplot(I(PGCR-PCRLIN-PCRRETR)~deltaPCR,annDF,
           main='I(PGCR-PCRLIN-PCRRETR)~deltaPCR',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on PFLIT", fig.align="center"}

p1<-xyplot(I(PFLITA+PFLITB)~PFLIT,annDF,
           main='I(PFLITA+PFLITB)~PFLIT',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on P storage", fig.align="center"}

p1<-xyplot(I(PUP+PLRETR+PWRETR+PFRRETR+PCRRETR)~I(PGL+PGFR+PGCR+PGW),annDF,
           main='I(PUP+PLRETR+PWRETR+PFRRETR+PCRRETR)~I(PGL+PGFR+PGCR+PGW)',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on P storage", fig.align="center"}

p1<-xyplot(I(PUP+PLRETR+PWRETR+PFRRETR+PCRRETR-PGL-PGFR-PGCR-PGW)~deltaPSTOR,annDF,
           main='I(PUP+PLRETR+PWRETR+PFRRETR+PCRRETR-PGL-PGFR-PGCR-PGW)~deltaPSTOR',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on P storage", fig.align="center"}

p1<-xyplot(I(PDEP+PWEA+PLITIN+PWLIN+PCRLIN+PFRLIN-PUP-PLEACH)~I(deltaPSOIL+deltaPFLIT+deltaPCLITB),annDF,
           main='I(PDEP+PWEA+PLITIN+PWLIN+PCRLIN+PFRLIN-PUP-PLEACH)~I(deltaPSOIL+deltaPFLIT+deltaPCLITB)',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on P soil", fig.align="center"}

p1<-xyplot(I(PPMIN+PPORG)~PSOIL,annDF,
           main='I(PPMIN+PPORG)~PSOIL',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on inorganic P", fig.align="center"}

p1<-xyplot(I(PLAB+PSEC+POCC+PPAR)~PPMIN,annDF,
           main='I(PLAB+PSEC+POCC+PPAR)~PPMIN',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on inorganic P", fig.align="center"}

p1<-xyplot(I(PLAB+PSEC+POCC+PPAR+PPORG)~PSOIL,annDF,
           main='I(PLAB+PSEC+POCC+PPAR+PPORG)~PSOIL',auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```



## 3. Checking time-invariant variables against validation data


#### Major carbon pools

Firstly we will check the major carbon pools, as these data are provided in Table 1 in the parameter file. 

Note that:
      
* CFR combines fineroot (< 2 mm in diameter) and intermediate root (2-3 mm) in the observation;
* CSOIL is for top 10 cm of soil in the observation;
* CL includes overstorey leaf only in the observation;
* CW includes branch and stem in the model simulation.


Now we make the tables to compare simulation results with observation data.

```{r, echo=FALSE, message=FALSE, warning=FALSE}

### create a DF to store observation data for vegetation carbon stocks
vegDF <- data.frame(c("CL", "CW", "CFR", "CCR", "CSOIL"), NA, NA)
colnames(vegDF) <- c("Variable", 
                     "observed",
                     "simulated")

vegDF$observed[vegDF$Variable=="CL"] <- "151 ± 14"
vegDF$observed[vegDF$Variable=="CW"] <- "4558 ± 321"
vegDF$observed[vegDF$Variable=="CFR"] <- "227 ± 5"
vegDF$observed[vegDF$Variable=="CCR"] <- "606 ± 60"
vegDF$observed[vegDF$Variable=="CSOIL"] <- "2183 ± 280"


### calcualte annual means in the simulated data
poolDF <- subset(modDF, year <= 2016 & year > 2012)

poolDF <- summaryBy(CL+CW+CFR+CCR+CSOIL~year, data=poolDF, FUN=mean, na.rm=T, keep.names=T)

### assign values
vegDF$simulated[vegDF$Variable=="CL"] <- round(poolDF$CL[poolDF$year=="2016"], 0)
vegDF$simulated[vegDF$Variable=="CW"] <- round(poolDF$CW[poolDF$year=="2016"], 0)
vegDF$simulated[vegDF$Variable=="CFR"] <- round(poolDF$CFR[poolDF$year=="2016"], 0)
vegDF$simulated[vegDF$Variable=="CCR"] <- round(poolDF$CCR[poolDF$year=="2016"], 0)
vegDF$simulated[vegDF$Variable=="CSOIL"] <- round(poolDF$CSOIL[poolDF$year=="2016"], 0)

knitr::kable(vegDF, caption = "Validation of major carbon pools")

```


#### Allocation coefficients

Allocation coefficients are calculated different comparing the data and the model. In the EucFACE data, allocation to leaf includes allocation to overstorey and understorey leaves, and allocation to root includes allocation to overstorey and understorey roots. In the data, there is also an additional allocation coefficient to Mycorrhizae, which can be grouped with allocation to root as total belowground allocation. This total belowground allocation is comparable to allocation coefficient to root in the model. 


```{r, echo=FALSE, message=FALSE, warning=FALSE}

### create a DF to store observation data for allocation coefficients
allocDF <- data.frame(c("leaf", "wood", "root", "mycorrhizae", "belowground"), NA, NA)
colnames(allocDF) <- c("Variable", 
                        "observed",
                        "simulated")

allocDF$observed[allocDF$Variable=="leaf"] <- "0.48 ± 0.04"
allocDF$observed[allocDF$Variable=="wood"] <- "0.20 ± 0.03"
allocDF$observed[allocDF$Variable=="root"] <- "0.22 ± 0.05"
allocDF$observed[allocDF$Variable=="mycorrhizae"] <- "0.10 ± 0.07"
allocDF$observed[allocDF$Variable=="belowground"] <- "0.32"


### calcualte annual means in the simulated data
subDF <- subset(modDF, year <= 2016 & year > 2012)

fluxDF <- summaryBy(GPP+NEP+NPP+CGL+CGW+CGFR+CGCR+RAU~year, data=subDF, FUN=sum, na.rm=T, keep.names=T)

### assign values
allocDF$simulated[allocDF$Variable=="leaf"] <- round(mean(fluxDF$CGL/fluxDF$NPP),2)
allocDF$simulated[allocDF$Variable=="wood"] <- round(mean(fluxDF$CGW/fluxDF$NPP),2)
allocDF$simulated[allocDF$Variable=="belowground"] <- round(mean(fluxDF$CGFR/fluxDF$NPP),2)

knitr::kable(allocDF, caption = "Validation of major carbon pools")

```



#### Major carbon fluxes

We now summarize major carbon fluxes (e.g. GPP, NPP, NEP, CUE).

```{r, echo=FALSE, message=FALSE, warning=FALSE}

### create a DF to store observation data for allocation coefficients
outDF <- data.frame(c("NEP", "GPP", "NPP", "CUE", "RAU"), NA, NA)
colnames(outDF) <- c("Variable", 
                     "observed",
                     "simulated")

outDF$observed[outDF$Variable=="NEP"] <- "-73 to 28"
outDF$observed[outDF$Variable=="GPP"] <- "1563 ± 200"
outDF$observed[outDF$Variable=="NPP"] <- "484 ± 63"
outDF$observed[outDF$Variable=="CUE"] <- "0.31 ± 0.03"
outDF$observed[outDF$Variable=="RAU"] <- "1079 ± 140"


### these fluxes were calculated above already
### assign values
outDF$simulated[outDF$Variable=="NEP"] <- round(mean(fluxDF$NEP),2)
outDF$simulated[outDF$Variable=="GPP"] <- round(mean(fluxDF$GPP),2)
outDF$simulated[outDF$Variable=="NPP"] <- round(mean(fluxDF$NPP),2)
outDF$simulated[outDF$Variable=="CUE"] <- round(mean(fluxDF$NPP/fluxDF$GPP),2)
outDF$simulated[outDF$Variable=="RAU"] <- round(mean(fluxDF$RAU),2)

knitr::kable(outDF, caption = "Validation of major carbon fluxes")

```



#### Major nutrient pools and fluxes

Below we provide several variables to help constrain the nutrient cycles in the model, namely labile inorganic P pool (PLAB), soil net N and P mineralization rate (NMIN and PMIN), plant N and P uptake (NUP and PUP), and soil N and P leaching (NLEACH and PLEACH). We did not include total soil P pool, because its size could be misleading given that the majority of the P in the soil is stored as occluded form unavailable for plants. Note that in the table below, simulated results are for top 30 cm of the soil, but observed data are for top 10 cm only. 
    

```{r, echo=FALSE, message=FALSE, warning=FALSE}

### create a DF to store observation data for vegetation carbon stocks
pDF <- data.frame(c("PLAB", "PMIN", "NMIN", "NUP", "PUP",
                    "NLEACH", "PLEACH"), NA, NA)
colnames(pDF) <- c("Variable", 
                     "observed",
                     "simulated")

pDF$observed[pDF$Variable=="PLAB"] <- "0.17 ± 0.05"
pDF$observed[pDF$Variable=="PMIN"] <- "0.3 ± 0.08"
pDF$observed[pDF$Variable=="NMIN"] <- "8.81 ± 1.65"


### calcualte annual means in the simulated data
subDF <- subset(modDF, year <= 2016 & year > 2012)

poolDF <- summaryBy(PLAB~year, data=subDF, FUN=mean, na.rm=T, keep.names=T)
fluxDF <- summaryBy(PMIN+NMIN+NLEACH+PLEACH+NUP+PUP~year, data=subDF, FUN=sum, na.rm=T, keep.names=T)

### assign values
pDF$simulated[pDF$Variable=="PLAB"] <- round(poolDF$PLAB[poolDF$year=="2016"], 3)
pDF$simulated[pDF$Variable=="PMIN"] <- round(mean(fluxDF$PMIN), 3)
pDF$simulated[pDF$Variable=="NMIN"] <- round(mean(fluxDF$NMIN), 3)
pDF$simulated[pDF$Variable=="PLEACH"] <- round(mean(fluxDF$PLEACH), 3)
pDF$simulated[pDF$Variable=="NLEACH"] <- round(mean(fluxDF$NLEACH), 3)
pDF$simulated[pDF$Variable=="PUP"] <- round(mean(fluxDF$PUP), 3)
pDF$simulated[pDF$Variable=="NUP"] <- round(mean(fluxDF$NUP), 3)

knitr::kable(pDF, caption = "Validation of key nutrient cycle variables")

```



#### Stoichiometry

Below we check major C:N, C:P, and N:P ratios. 


```{r, echo=FALSE, message=FALSE, warning=FALSE}

### create a DF to store observation data 
stDF <- data.frame(c("leaf", "sapwood", "wood", "fineroot", "soil"),
                   NA, NA, NA, NA, NA, NA)
colnames(stDF) <- c("Variable", "obsCN", "simCN", 
                    "obsCP", "simCP", "obsNP", "simNP")

stDF$obsCN[stDF$Variable=="leaf"] <- "35.5 ± 2.7"
stDF$obsCN[stDF$Variable=="sapwood"] <- "101.6 ± 14.7"
stDF$obsCN[stDF$Variable=="wood"] <- "110.2 ± 30.3"
stDF$obsCN[stDF$Variable=="fineroot"] <- "56.9 ± 4.6"
stDF$obsCN[stDF$Variable=="soil"] <- "13.8 ± 1.0"

stDF$obsCP[stDF$Variable=="leaf"] <- "722 ± 33"
stDF$obsCP[stDF$Variable=="sapwood"] <- "3705 ± 702"
stDF$obsCP[stDF$Variable=="wood"] <- "7696 ± 982"
stDF$obsCP[stDF$Variable=="fineroot"] <- "1626 ± 81"
stDF$obsCP[stDF$Variable=="soil"] <- "224 ± 39"

stDF$obsNP[stDF$Variable=="leaf"] <- "22.9 ± 0.1"
stDF$obsNP[stDF$Variable=="sapwood"] <- "35.6 ± 2.1"
stDF$obsNP[stDF$Variable=="wood"] <- "33.7 ± 2.7"
stDF$obsNP[stDF$Variable=="fineroot"] <- "28.7 ± 3.3"
stDF$obsNP[stDF$Variable=="soil"] <- "16.4 ± 3.4"


### create a DF to store simulated stocks
tmpDF <- data.frame(c("CL", "CW", "CFR", "CSOIL",
                     "NL", "NW", "NFR", "NSOIL",
                     "PL", "PW", "PFR", "PSOIL"), NA, NA)
colnames(tmpDF) <- c("Variable", 
                     "observed",
                     "simulated")

### calcualte annual means in the simulated data
poolDF <- subset(modDF, year <= 2016 & year > 2012)

poolDF <- summaryBy(CL+CW+CFR+CSOIL+NL+NW+NFR+NSOIL+PL+PW+PFR+PSOIL~year, data=poolDF, FUN=mean, na.rm=T, keep.names=T)

### assign values
stDF$simCN[stDF$Variable=="leaf"] <- round(poolDF$CL[poolDF$year=="2016"]/poolDF$NL[poolDF$year=="2016"], 1)
stDF$simCN[stDF$Variable=="wood"] <- round(poolDF$CW[poolDF$year=="2016"]/poolDF$NW[poolDF$year=="2016"], 1)
stDF$simCN[stDF$Variable=="fineroot"] <- round(poolDF$CFR[poolDF$year=="2016"]/poolDF$NFR[poolDF$year=="2016"], 1)
stDF$simCN[stDF$Variable=="soil"] <- round(poolDF$CSOIL[poolDF$year=="2016"]/poolDF$NSOIL[poolDF$year=="2016"], 1)


stDF$simCP[stDF$Variable=="leaf"] <- round(poolDF$CL[poolDF$year=="2016"]/poolDF$PL[poolDF$year=="2016"], 1)
stDF$simCP[stDF$Variable=="wood"] <- round(poolDF$CW[poolDF$year=="2016"]/poolDF$PW[poolDF$year=="2016"], 1)
stDF$simCP[stDF$Variable=="fineroot"] <- round(poolDF$CFR[poolDF$year=="2016"]/poolDF$PFR[poolDF$year=="2016"], 1)
stDF$simCP[stDF$Variable=="soil"] <- round(poolDF$CSOIL[poolDF$year=="2016"]/poolDF$PSOIL[poolDF$year=="2016"], 1)


stDF$simNP[stDF$Variable=="leaf"] <- round(poolDF$NL[poolDF$year=="2016"]/poolDF$PL[poolDF$year=="2016"], 1)
stDF$simNP[stDF$Variable=="wood"] <- round(poolDF$NW[poolDF$year=="2016"]/poolDF$PW[poolDF$year=="2016"], 1)
stDF$simNP[stDF$Variable=="fineroot"] <- round(poolDF$NFR[poolDF$year=="2016"]/poolDF$PFR[poolDF$year=="2016"], 1)
stDF$simNP[stDF$Variable=="soil"] <- round(poolDF$NSOIL[poolDF$year=="2016"]/poolDF$PSOIL[poolDF$year=="2016"], 1)

knitr::kable(stDF, caption = "Validation of key stoichiometry")

```


#### Nutreint retranslocation coefficients

We only asked for the leaf N and P retranslocation flux in the output protocol. To obtain the coefficient, we will need the production flux. 

```{r, echo=FALSE, message=FALSE, warning=FALSE}

### subset and calculate
subDF <- subset(modDF, year <= 2016 & year > 2012)

tmpDF <- summaryBy(NGL+PGL+NLRETR+PLRETR~year, data=subDF, FUN=sum, keep.names=T, na.rm=T)


### create DF for output
rtDF <- data.frame(c("leafN", "leafP"), NA, NA)
colnames(rtDF) <- c("Variable", "observed", "simulated")

### assign values
rtDF$observed[rtDF$Variable=="leafN"] <- "0.31 ± 0.04"
rtDF$observed[rtDF$Variable=="leafP"] <- "0.53 ± 0.04"

rtDF$simulated[rtDF$Variable=="leafN"] <- round(mean(tmpDF$NLRETR/tmpDF$NGL),2)
rtDF$simulated[rtDF$Variable=="leafP"] <- round(mean(tmpDF$PLRETR/tmpDF$PGL),2)


knitr::kable(rtDF, caption = "Validation of leaf retranslocation coefficients")




```






## Checking time-varying variables against validation data

#### Leaf area index

A time series LAI data over the period of 2012 - 2016 was provided for validation purpose. Models should aim to match the magnitude of LAI as well as its temporal patterns. 

The temporal pattern based on all available data is provided in the figure below:

```{r, fig.cap = "Time-varying LAI plot", fig.align="center", echo=FALSE, message=FALSE, warning=FALSE}

### validation LAI
laiDF <- read.csv("validation_dataset/EucFACE_LAI_2012_2016.csv")
laiDF <- laiDF[laiDF$Trt=="aCO2",]
laiDF$Date <- as.Date(as.character(laiDF$Date))

### simulated LAI, subset
subDF <- subset(modDF, year <= 2016)
subDF <- subDF[,c("year", "doy", "Date", "LAI")]
subDF$Date <- as.Date(as.character(subDF$Date))

### merge the two dataset
testDF1 <- merge(subDF, laiDF, by="Date", all=T)

### plot all data
p1 <- ggplot(testDF1, aes(x=Date)) +
        geom_errorbar(aes(ymin=lai-laiSD,
                        ymax=lai+laiSD, color="obs"))+
        geom_line(aes(y=LAI, color="sim"), lwd = 1) +
        theme_linedraw() +
        theme(panel.grid.minor=element_blank(),
              axis.title.x = element_text(size=14), 
              axis.text.x = element_text(size=12),
              axis.text.y=element_text(size=12),
              axis.title.y=element_text(size=14),
              legend.text=element_text(size=12),
              legend.title=element_text(size=12),
              panel.grid.major=element_blank(),
              plot.title = element_text(size = 10, face = "bold"),
              legend.position="right")+
        ylab("LAI")+
        scale_colour_manual("", 
                            values = c("obs"="black", "sim"="red2"),
                            labels = c("Observed", "Simulated"))

    plot(p1)
    

```

Now we can check the goodness-of-fit of all days where observation is available. A perfect fit should have slope of 1 and intercept of 0. 

```{r, fig.cap = "Goodness of fit for LAI plot", fig.align="center", echo=FALSE, message=FALSE, warning=FALSE}

### subset only days where observations are available
testDF2 <- testDF1[complete.cases(testDF1$lai),]

lm.fit <- lm(testDF2$LAI~testDF2$lai)


### plot all data
p1 <- ggplot(testDF2, aes(x=lai, y=LAI)) +
        geom_point()+
        theme_linedraw() +
        geom_smooth(method="lm")+
        theme(panel.grid.minor=element_blank(),
              axis.title.x = element_text(size=14), 
              axis.text.x = element_text(size=12),
              axis.text.y=element_text(size=12),
              axis.title.y=element_text(size=14),
              legend.text=element_text(size=12),
              legend.title=element_text(size=12),
              panel.grid.major=element_blank(),
              plot.title = element_text(size = 10, face = "bold"),
              legend.position="right")+
        ylab("simulated LAI")+
        xlab("observed LAI")

    plot(p1)
    

```

The linear fit results are: 

```{r, echo=FALSE, message=FALSE, warning=FALSE}
print(paste0("slope = ", round(coef(lm.fit)[2], 2)))
print(paste0("intercept = ", round(coef(lm.fit)[1], 2)))

```



#### Soil respiration
The measured soil respiration rate represents both root and soil heterotrophic respiration flux. It was up-scaled from the LICOR chambers by averaging all measurements within the same treatment. It was a model product, in that we used DAMM model to establish relationship with soil temperature, and then obtained the daily rate throughout the year. Nevertheless, we expect modelers to provide a good match simulation to this dataset. 

Note that we didn't ask the modelers to output soil respiration flux in the output protocol. Please add heterotrophic respiration and root respiration to obtain soil respiration flux. Also, please note that, the unit for all carbon fluxes is given in the output protocol, as gC m-2 d-1. 


```{r, fig.cap = "Time-varying soil respiration plot", fig.align="center", echo=FALSE, message=FALSE, warning=FALSE}

### validation Rsoil
rsoilDF <- read.csv("validation_dataset/EucFACE_daily_soil_respiration_flux_2013_2015.csv")
rsoilDF <- rsoilDF[rsoilDF$Trt=="aCO2",]
rsoilDF$Date <- as.Date(as.character(rsoilDF$Date))

### convert unit, from mg m-2 d-1 to g m-2 d-1
rsoilDF$Rsoil_g_m2_d <- rsoilDF$Rsoil_mg_m2_d / 1000.0
rsoilDF$RsoilSD_g <- rsoilDF$RsoilSD / 1000.0


### simulated Rsoil, subset
subDF <- subset(modDF, year <= 2015 & year > 2012)
subDF <- subDF[,c("year", "doy", "Date", "RHET", "RCR", "RFR")]
subDF$Date <- as.Date(as.character(subDF$Date))
subDF$Rsoil_sim <- with(subDF, RHET+RCR+RFR)



### merge the two dataset
testDF1 <- merge(subDF, rsoilDF, by="Date", all=T)

### plot all data
p1 <- ggplot(testDF1, aes(x=Date)) +
        geom_errorbar(aes(ymin=Rsoil_g_m2_d-RsoilSD_g,
                        ymax=Rsoil_g_m2_d+RsoilSD_g, color="obs"))+
        geom_line(aes(y=Rsoil_sim, color="sim"), lwd = 1) +
        theme_linedraw() +
        theme(panel.grid.minor=element_blank(),
              axis.title.x = element_text(size=14), 
              axis.text.x = element_text(size=12),
              axis.text.y=element_text(size=12),
              axis.title.y=element_text(size=14),
              legend.text=element_text(size=12),
              legend.title=element_text(size=12),
              panel.grid.major=element_blank(),
              plot.title = element_text(size = 10, face = "bold"),
              legend.position="right")+
        ylab("Soil respiration flux")+
        scale_colour_manual("", 
                            values = c("obs"="black", "sim"="red2"),
                            labels = c("Observed", "Simulated"))

    plot(p1)
    


```


#### Soil water content
Soil water content is more complex and non-linear, depending on many model-specific settings. The validation dataset only serves as a guidance to evaluate your model performance. 


```{r, echo=FALSE, message=FALSE, warning=FALSE}

### validation Rsoil
swcDF <- read.csv("validation_dataset/EucFACE_SWC_2012_2019.csv")

### more to be filled. 


```

End. 