---
title: "EucFACE Simulation Output Validation"
author: "Mingkai Jiang"
date: "1/4/2021"
output: pdf_document
#fig_width: 3 
#fig_height: 2 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width=6, fig.height=4)


#### clear wk space
rm(list=ls(all=TRUE))

#### Source functions and packages
source("prepare.R")

#### select the model abbreviation
#### options are:
####             GDAYN: GDAY, CN version
####             GDAYP: GDAY, CNP version
####             QUNIC: QUINCY
####             OCHDP: ORCHIDEE, CNP version
####             OCHDN: ORCHIDEE, CN version
####             LPJGN: LPJ-Guess, CN version
####             LPJGP: LPJ-Guess, CNP version
####             CABLP: CABLE-POP, CNP version
####             ELMXX: ELM, CNP version

mod.abb <- "GDAYP"


```

## Introduction

This is an R Markdown document to evaluate the model simulation results for the new EucFACE multi-model intercomparison project, based on mass balance checks and validation datasets. 

To use this Markdown, please create two folders within this repository and place the relevant data files into each folder. 

- Create a folder "simulation_output", and place the model simulation results into this folder (note, only the file containing ambient treatment over the period of 2012 - 2019).

- Create a folder "validation_dataset", and place the validation datasets into this folder (data can be obtained via the CloudStor link sent previously).


This script will firstly check some basic mass balances, the compare the simulation results against some time-invariant parameters provided in the parameter list, and finally check several time-series variables. All checks are performed for ambient CO2 treatment only. 



```{r, echo=FALSE, message=FALSE, warning=FALSE}
### read in simulation results and get it in shape for comparison.
### the naming of the file follows rules identified in the output protocol. 
### Note that this is the daily file. 
modDF <- read.csv(paste0("simulation_output/EUC_", mod.abb, "_OBS_VAR_AMB_NOP_D.csv"),
                  skip=1)

### checking number of column in the original dataframe
ncol <- ncol(modDF)
#print(paste0("no. of columns is ", ncol))

### add date to the dataset
for (i in 2012:2019) {
    
    date.list <- as.Date((modDF$doy[modDF$year==i]-1), 
                                           origin = paste0(i, "-01-01"))
    
    modDF$Date[modDF$year == i] <- as.character(date.list)
}

modDF$Date <- as.Date(modDF$Date)


### revise the GDAY output names following output protocol (delete this once GDAY output is properly set)
names(modDF)[names(modDF) == "lai"] <- "LAI"
names(modDF)[names(modDF) == "hetero_resp"] <- "RHET"
names(modDF)[names(modDF) == "shoot"] <- "CL"
names(modDF)[names(modDF) == "root"] <- "CFR"
names(modDF)[names(modDF) == "croot"] <- "CCR"

names(modDF)[names(modDF) == "pmineralisation"] <- "PMIN"
names(modDF)[names(modDF) == "inorglabp"] <- "PLAB"
names(modDF)[names(modDF) == "nmineralisation"] <- "NMIN"

names(modDF)[names(modDF) == "soiln"] <- "NSOIL"
names(modDF)[names(modDF) == "soilp"] <- "PSOIL"
names(modDF)[names(modDF) == "shootn"] <- "NL"
names(modDF)[names(modDF) == "rootn"] <- "NFR"
names(modDF)[names(modDF) == "crootn"] <- "NCR"
names(modDF)[names(modDF) == "shootp"] <- "PL"
names(modDF)[names(modDF) == "rootp"] <- "PFR"
names(modDF)[names(modDF) == "crootp"] <- "PCR"

names(modDF)[names(modDF) == "leafretransn"] <- "NLRETR"
names(modDF)[names(modDF) == "leafretransp"] <- "PLRETR"

names(modDF)[names(modDF) == "nloss"] <- "NLEACH"
names(modDF)[names(modDF) == "ploss"] <- "PLEACH"

names(modDF)[names(modDF) == "nuptake"] <- "NUP"
names(modDF)[names(modDF) == "puptake"] <- "PUP"

names(modDF)[names(modDF) == "cpleaf"] <- "CGL"
names(modDF)[names(modDF) == "cproot"] <- "CGFR"
names(modDF)[names(modDF) == "cpcroot"] <- "CGCR"

names(modDF)[names(modDF) == "npleaf"] <- "NGL"
names(modDF)[names(modDF) == "nproot"] <- "NGFR"
names(modDF)[names(modDF) == "npcroot"] <- "NGCR"

names(modDF)[names(modDF) == "ppleaf"] <- "PGL"
names(modDF)[names(modDF) == "pproot"] <- "PGFR"
names(modDF)[names(modDF) == "ppcroot"] <- "PGCR"


### add extra column where GDAY simulation doesn't output for now
# coarse root respiration
modDF$RCR <- 0.0

# fine root respiration
modDF$RFR <- 0.0

# merge branch and stem together to create wood
modDF$CW <- modDF$branch + modDF$stem
modDF$NW <- modDF$branchn + modDF$stemn
modDF$PW <- modDF$branchp + modDF$stemp

modDF$CGW <- modDF$cpbranch + modDF$cpstem
modDF$NGW <- modDF$npbranch + modDF$npstemimm
modDF$PGW <- modDF$ppbranch + modDF$ppstemimm

# add storage pool
modDF$CSTOR <- 0.0

# merge all soil pools together to create total soil
modDF$CSOIL <- with(modDF, activesoil+slowsoil+passivesoil)




### convert unit from current GDAY default of t ha-1 to whatever is defined in the output protocol
modDF$RHET <- with(modDF, RHET * 100)
modDF$RFR <- with(modDF, RFR * 100)
modDF$RCR <- with(modDF, RCR * 100)
modDF$CL <- with(modDF, CL * 100)
modDF$CW <- with(modDF, CW * 100)
modDF$CFR <- with(modDF, CFR * 100)
modDF$CCR <- with(modDF, CCR * 100)

modDF$CSOIL <- with(modDF, CSOIL * 100)
modDF$NSOIL <- with(modDF, NSOIL * 100)
modDF$PSOIL <- with(modDF, PSOIL * 100)

modDF$PMIN <- with(modDF, PMIN * 100)
modDF$PLAB <- with(modDF, PLAB * 100)
modDF$NMIN <- with(modDF, NMIN * 100)

modDF$NL <- with(modDF, NL * 100)
modDF$NW <- with(modDF, NW * 100)
modDF$NFR <- with(modDF, NFR * 100)
modDF$NCR <- with(modDF, NCR * 100)
modDF$PL <- with(modDF, PL * 100)
modDF$PW <- with(modDF, PW * 100)
modDF$PFR <- with(modDF, PFR * 100)
modDF$PCR <- with(modDF, PCR * 100)

modDF$NLRETR <- with(modDF, NLRETR * 100)
modDF$PLRETR <- with(modDF, PLRETR * 100)

modDF$NLEACH <- with(modDF, NLEACH * 100)
modDF$PLEACH <- with(modDF, PLEACH * 100)

modDF$NUP <- with(modDF, NUP * 100)
modDF$PUP <- with(modDF, PUP * 100)

modDF$CGL <- with(modDF, CGL * 100)
modDF$CGW <- with(modDF, CGW * 100)
modDF$CGFR <- with(modDF, CGFR * 100)
modDF$CGCR <- with(modDF, CGCR * 100)

modDF$NGL <- with(modDF, NGL * 100)
modDF$NGW <- with(modDF, NGW * 100)
modDF$NGFR <- with(modDF, NGFR * 100)
modDF$NGCR <- with(modDF, NGCR * 100)

modDF$PGL <- with(modDF, PGL * 100)
modDF$PGW <- with(modDF, PGW * 100)
modDF$PGFR <- with(modDF, PGFR * 100)
modDF$PGCR <- with(modDF, PGCR * 100)




```


## Checking mass balance

#### Net Ecosystem Production (NEP)

We define NEP as: NEP = GPP - Reco - Offsite C losses

More to be added. Do parameters first. 



## Checking time-invariant parameters, fluxes and stocks against validation data


#### Major carbon pools

Firstly we will check the major carbon pools, as these data are provided in Table 1 in the parameter file. 

Note that:
      
    - CFR combines fineroot (< 2 mm in diameter) and intermediate root (2-3 mm) in the observation;
    - CSOIL is for top 10 cm of soil in the observation;
    - CL includes overstorey leaf only in the observation;
    - CW includes branch and stem in the model simulation.




```{r, echo=FALSE, message=FALSE, warning=FALSE}

### create a DF to store observation data for vegetation carbon stocks
vegDF <- data.frame(c("CL", "CW", "CFR", "CCR", "CSOIL"), NA, NA)
colnames(vegDF) <- c("Variable", 
                     "observed",
                     "simulated")

vegDF$observed[vegDF$Variable=="CL"] <- "151 ± 14"
vegDF$observed[vegDF$Variable=="CW"] <- "4558 ± 321"
vegDF$observed[vegDF$Variable=="CFR"] <- "227 ± 5"
vegDF$observed[vegDF$Variable=="CCR"] <- "606 ± 60"
vegDF$observed[vegDF$Variable=="CSOIL"] <- "2183 ± 280"


### calcualte annual means in the simulated data
poolDF <- subset(modDF, year <= 2016 & year > 2012)

poolDF <- summaryBy(CL+CW+CFR+CCR+CSOIL~year, data=poolDF, FUN=mean, na.rm=T, keep.names=T)

### assign values
vegDF$simulated[vegDF$Variable=="CL"] <- round(poolDF$CL[poolDF$year=="2016"], 0)
vegDF$simulated[vegDF$Variable=="CW"] <- round(poolDF$CW[poolDF$year=="2016"], 0)
vegDF$simulated[vegDF$Variable=="CFR"] <- round(poolDF$CFR[poolDF$year=="2016"], 0)
vegDF$simulated[vegDF$Variable=="CCR"] <- round(poolDF$CCR[poolDF$year=="2016"], 0)
vegDF$simulated[vegDF$Variable=="CSOIL"] <- round(poolDF$CSOIL[poolDF$year=="2016"], 0)

knitr::kable(vegDF, caption = "Validation of major carbon pools")

```



#### Major nutrient pools and fluxes

Below we provide several variables to help constrain the nutrient cycles in the model, namely labile inorganic P pool (PLAB), soil net N and P mineralization rate (NMIN and PMIN), plant N and P uptake (NUP and PUP), and soil N and P leaching (NLEACH and PLEACH). We did not include total soil P pool, because its size could be misleading given that the majority of the P in the soil is stored as occluded form unavailable for plants. Note that in the table below, simulated results are for top 30 cm of the soil, but observed data are for top 10 cm only. 
    

```{r, echo=FALSE, message=FALSE, warning=FALSE}

### create a DF to store observation data for vegetation carbon stocks
pDF <- data.frame(c("PLAB", "PMIN", "NMIN", "NUP", "PUP",
                    "NLEACH", "PLEACH"), NA, NA)
colnames(pDF) <- c("Variable", 
                     "observed",
                     "simulated")

pDF$observed[pDF$Variable=="PLAB"] <- "0.17 ± 0.05"
pDF$observed[pDF$Variable=="PMIN"] <- "0.3 ± 0.08"
pDF$observed[pDF$Variable=="NMIN"] <- "8.81 ± 1.65"


### calcualte annual means in the simulated data
subDF <- subset(modDF, year <= 2016 & year > 2012)

poolDF <- summaryBy(PLAB~year, data=subDF, FUN=mean, na.rm=T, keep.names=T)
fluxDF <- summaryBy(PMIN+NMIN+NLEACH+PLEACH+NUP+PUP~year, data=subDF, FUN=sum, na.rm=T, keep.names=T)

### assign values
pDF$simulated[pDF$Variable=="PLAB"] <- round(poolDF$PLAB[poolDF$year=="2016"], 3)
pDF$simulated[pDF$Variable=="PMIN"] <- round(mean(fluxDF$PMIN), 3)
pDF$simulated[pDF$Variable=="NMIN"] <- round(mean(fluxDF$NMIN), 3)
pDF$simulated[pDF$Variable=="PLEACH"] <- round(mean(fluxDF$PLEACH), 3)
pDF$simulated[pDF$Variable=="NLEACH"] <- round(mean(fluxDF$NLEACH), 3)
pDF$simulated[pDF$Variable=="PUP"] <- round(mean(fluxDF$PUP), 3)
pDF$simulated[pDF$Variable=="NUP"] <- round(mean(fluxDF$NUP), 3)

knitr::kable(pDF, caption = "Validation of key nutrient cycle variables")

```



#### Stoichiometry

Below we check major C:N, C:P, and N:P ratios. 


```{r, echo=FALSE, message=FALSE, warning=FALSE}

### create a DF to store observation data 
stDF <- data.frame(c("leaf", "sapwood", "wood", "fineroot", "soil"),
                   NA, NA, NA, NA, NA, NA)
colnames(stDF) <- c("Variable", "obsCN", "simCN", 
                    "obsCP", "simCP", "obsNP", "simNP")

stDF$obsCN[stDF$Variable=="leaf"] <- "35.5 ± 2.7"
stDF$obsCN[stDF$Variable=="sapwood"] <- "101.6 ± 14.7"
stDF$obsCN[stDF$Variable=="wood"] <- "110.2 ± 30.3"
stDF$obsCN[stDF$Variable=="fineroot"] <- "56.9 ± 4.6"
stDF$obsCN[stDF$Variable=="soil"] <- "13.8 ± 1.0"

stDF$obsCP[stDF$Variable=="leaf"] <- "722 ± 33"
stDF$obsCP[stDF$Variable=="sapwood"] <- "3705 ± 702"
stDF$obsCP[stDF$Variable=="wood"] <- "7696 ± 982"
stDF$obsCP[stDF$Variable=="fineroot"] <- "1626 ± 81"
stDF$obsCP[stDF$Variable=="soil"] <- "224 ± 39"

stDF$obsNP[stDF$Variable=="leaf"] <- "22.9 ± 0.1"
stDF$obsNP[stDF$Variable=="sapwood"] <- "35.6 ± 2.1"
stDF$obsNP[stDF$Variable=="wood"] <- "33.7 ± 2.7"
stDF$obsNP[stDF$Variable=="fineroot"] <- "28.7 ± 3.3"
stDF$obsNP[stDF$Variable=="soil"] <- "16.4 ± 3.4"


### create a DF to store simulated stocks
tmpDF <- data.frame(c("CL", "CW", "CFR", "CSOIL",
                     "NL", "NW", "NFR", "NSOIL",
                     "PL", "PW", "PFR", "PSOIL"), NA, NA)
colnames(tmpDF) <- c("Variable", 
                     "observed",
                     "simulated")

### calcualte annual means in the simulated data
poolDF <- subset(modDF, year <= 2016 & year > 2012)

poolDF <- summaryBy(CL+CW+CFR+CSOIL+NL+NW+NFR+NSOIL+PL+PW+PFR+PSOIL~year, data=poolDF, FUN=mean, na.rm=T, keep.names=T)

### assign values
stDF$simCN[stDF$Variable=="leaf"] <- round(poolDF$CL[poolDF$year=="2016"]/poolDF$NL[poolDF$year=="2016"], 1)
stDF$simCN[stDF$Variable=="wood"] <- round(poolDF$CW[poolDF$year=="2016"]/poolDF$NW[poolDF$year=="2016"], 1)
stDF$simCN[stDF$Variable=="fineroot"] <- round(poolDF$CFR[poolDF$year=="2016"]/poolDF$NFR[poolDF$year=="2016"], 1)
stDF$simCN[stDF$Variable=="soil"] <- round(poolDF$CSOIL[poolDF$year=="2016"]/poolDF$NSOIL[poolDF$year=="2016"], 1)


stDF$simCP[stDF$Variable=="leaf"] <- round(poolDF$CL[poolDF$year=="2016"]/poolDF$PL[poolDF$year=="2016"], 1)
stDF$simCP[stDF$Variable=="wood"] <- round(poolDF$CW[poolDF$year=="2016"]/poolDF$PW[poolDF$year=="2016"], 1)
stDF$simCP[stDF$Variable=="fineroot"] <- round(poolDF$CFR[poolDF$year=="2016"]/poolDF$PFR[poolDF$year=="2016"], 1)
stDF$simCP[stDF$Variable=="soil"] <- round(poolDF$CSOIL[poolDF$year=="2016"]/poolDF$PSOIL[poolDF$year=="2016"], 1)


stDF$simNP[stDF$Variable=="leaf"] <- round(poolDF$NL[poolDF$year=="2016"]/poolDF$PL[poolDF$year=="2016"], 1)
stDF$simNP[stDF$Variable=="wood"] <- round(poolDF$NW[poolDF$year=="2016"]/poolDF$PW[poolDF$year=="2016"], 1)
stDF$simNP[stDF$Variable=="fineroot"] <- round(poolDF$NFR[poolDF$year=="2016"]/poolDF$PFR[poolDF$year=="2016"], 1)
stDF$simNP[stDF$Variable=="soil"] <- round(poolDF$NSOIL[poolDF$year=="2016"]/poolDF$PSOIL[poolDF$year=="2016"], 1)

knitr::kable(stDF, caption = "Validation of key stoichiometry")

```


#### Nutreint retranslocation coefficients

Using live and litter nutrient pools, we can infer plant nutrient retranslocation coefficients. 

```{r, echo=FALSE, message=FALSE, warning=FALSE}

### subset and calculate
subDF <- subset(modDF, year <= 2016 & year > 2012)

tmpDF <- summaryBy(NGL+PGL+NLRETR+PLRETR~year, data=subDF, FUN=sum, keep.names=T, na.rm=T)


### create DF for output
rtDF <- data.frame(c("leafN", "leafP"), NA, NA)
colnames(rtDF) <- c("Variable", "observed", "simulated")

### assign values
rtDF$observed[rtDF$Variable=="leafN"] <- "0.31 ± 0.04"
rtDF$observed[rtDF$Variable=="leafP"] <- "0.53 ± 0.04"

rtDF$simulated[rtDF$Variable=="leafN"] <- round(mean(tmpDF$NLRETR/tmpDF$NGL),2)
rtDF$simulated[rtDF$Variable=="leafP"] <- round(mean(tmpDF$PLRETR/tmpDF$PGL),2)


knitr::kable(rtDF, caption = "Validation of leaf retranslocation coefficients")




```






## Checking time-varying variables against validation data

#### Leaf area index

A time series LAI data over the period of 2012 - 2016 was provided for validation purpose. Models should aim to match the magnitude of LAI as well as its temporal patterns. 

The temporal pattern based on all available data is provided in the figure below:

```{r, fig.cap = "Time-varying LAI plot", fig.align="center", echo=FALSE, message=FALSE, warning=FALSE}

### validation LAI
laiDF <- read.csv("validation_dataset/EucFACE_LAI_2012_2016.csv")
laiDF <- laiDF[laiDF$Trt=="aCO2",]
laiDF$Date <- as.Date(as.character(laiDF$Date))

### simulated LAI, subset
subDF <- subset(modDF, year <= 2016)
subDF <- subDF[,c("year", "doy", "Date", "LAI")]
subDF$Date <- as.Date(as.character(subDF$Date))

### merge the two dataset
testDF1 <- merge(subDF, laiDF, by="Date", all=T)

### plot all data
p1 <- ggplot(testDF1, aes(x=Date)) +
        geom_errorbar(aes(ymin=lai-laiSD,
                        ymax=lai+laiSD, color="obs"))+
        geom_line(aes(y=LAI, color="sim"), lwd = 1) +
        theme_linedraw() +
        theme(panel.grid.minor=element_blank(),
              axis.title.x = element_text(size=14), 
              axis.text.x = element_text(size=12),
              axis.text.y=element_text(size=12),
              axis.title.y=element_text(size=14),
              legend.text=element_text(size=12),
              legend.title=element_text(size=12),
              panel.grid.major=element_blank(),
              plot.title = element_text(size = 10, face = "bold"),
              legend.position="right")+
        ylab("LAI")+
        scale_colour_manual("", 
                            values = c("obs"="black", "sim"="red2"),
                            labels = c("Observed", "Simulated"))

    plot(p1)
    

```

Now we can check the goodness-of-fit of all days where observation is available. A perfect fit should have slope of 1 and intercept of 0. 

```{r, fig.cap = "Goodness of fit for LAI plot", fig.align="center", echo=FALSE, message=FALSE, warning=FALSE}

### subset only days where observations are available
testDF2 <- testDF1[complete.cases(testDF1$lai),]

lm.fit <- lm(testDF2$LAI~testDF2$lai)


### plot all data
p1 <- ggplot(testDF2, aes(x=lai, y=LAI)) +
        geom_point()+
        theme_linedraw() +
        geom_smooth(method="lm")+
        theme(panel.grid.minor=element_blank(),
              axis.title.x = element_text(size=14), 
              axis.text.x = element_text(size=12),
              axis.text.y=element_text(size=12),
              axis.title.y=element_text(size=14),
              legend.text=element_text(size=12),
              legend.title=element_text(size=12),
              panel.grid.major=element_blank(),
              plot.title = element_text(size = 10, face = "bold"),
              legend.position="right")+
        ylab("simulated LAI")+
        xlab("observed LAI")

    plot(p1)
    

```

The linear fit results are: 

```{r, echo=FALSE, message=FALSE, warning=FALSE}
print(paste0("slope = ", round(coef(lm.fit)[2], 2)))
print(paste0("intercept = ", round(coef(lm.fit)[1], 2)))

```



#### Soil respiration
The measured soil respiration rate represents both root and soil heterotrophic respiration flux. It was up-scaled from the LICOR chambers by averaging all measurements within the same treatment. It was a model product, in that we used DAMM model to establish relationship with soil temperature, and then obtained the daily rate throughout the year. Nevertheless, we expect modelers to provide a good match simulation to this dataset. 

Note that we didn't ask the modelers to output soil respiration flux in the output protocol. Please add heterotrophic respiration and root respiration to obtain soil respiration flux. Also, please note that, the unit for all carbon fluxes is given in the output protocol, as gC m-2 d-1. 


```{r, fig.cap = "Time-varying soil respiration plot", fig.align="center", echo=FALSE, message=FALSE, warning=FALSE}

### validation Rsoil
rsoilDF <- read.csv("validation_dataset/EucFACE_daily_soil_respiration_flux_2013_2015.csv")
rsoilDF <- rsoilDF[rsoilDF$Trt=="aCO2",]
rsoilDF$Date <- as.Date(as.character(rsoilDF$Date))

### convert unit, from mg m-2 d-1 to g m-2 d-1
rsoilDF$Rsoil_g_m2_d <- rsoilDF$Rsoil_mg_m2_d / 1000.0
rsoilDF$RsoilSD_g <- rsoilDF$RsoilSD / 1000.0


### simulated Rsoil, subset
subDF <- subset(modDF, year <= 2015 & year > 2012)
subDF <- subDF[,c("year", "doy", "Date", "RHET", "RCR", "RFR")]
subDF$Date <- as.Date(as.character(subDF$Date))
subDF$Rsoil_sim <- with(subDF, RHET+RCR+RFR)



### merge the two dataset
testDF1 <- merge(subDF, rsoilDF, by="Date", all=T)

### plot all data
p1 <- ggplot(testDF1, aes(x=Date)) +
        geom_errorbar(aes(ymin=Rsoil_g_m2_d-RsoilSD_g,
                        ymax=Rsoil_g_m2_d+RsoilSD_g, color="obs"))+
        geom_line(aes(y=Rsoil_sim, color="sim"), lwd = 1) +
        theme_linedraw() +
        theme(panel.grid.minor=element_blank(),
              axis.title.x = element_text(size=14), 
              axis.text.x = element_text(size=12),
              axis.text.y=element_text(size=12),
              axis.title.y=element_text(size=14),
              legend.text=element_text(size=12),
              legend.title=element_text(size=12),
              panel.grid.major=element_blank(),
              plot.title = element_text(size = 10, face = "bold"),
              legend.position="right")+
        ylab("Soil respiration flux")+
        scale_colour_manual("", 
                            values = c("obs"="black", "sim"="red2"),
                            labels = c("Observed", "Simulated"))

    plot(p1)
    


```


#### Soil water content
Soil water content is more complex and non-linear, depending on many model-specific settings. The validation dataset only serves as a guidance to evaluate your model performance. 


```{r, echo=FALSE, message=FALSE, warning=FALSE}

### validation Rsoil
swcDF <- read.csv("validation_dataset/EucFACE_SWC_2012_2019.csv")

### more to be filled. 


```

End. 